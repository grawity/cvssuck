#!/usr/local/bin/ruby

# cvssuck - cvs repository retrieving tool via cvs client/server protocol

# author:
#  Tanaka Akira <akr@m17n.org>

require "socket" # to use gethostname

class CouldNotLock<Exception
end

class RetryLock<Exception
end

class InvalidUnlock<Exception
end

class CVSCommandFailure<Exception
end

class RCSCommandFailure<Exception
end

class CVSWork
  def initialize(cvsroot)
    @tmpdir = "/tmp/cvssuck-tmp-#{$$}"
    @tmpcount = 0
    @workdir = "#{@tmpdir}/w"
    Dir.mkdir(@tmpdir, 0700)
    Dir.mkdir("#{@workdir}")
    Dir.mkdir("#{@workdir}/CVS")
    open("#{@workdir}/CVS/Root", "w") {|f| f.print(cvsroot, "\n")}
  end

  def tmpfilename(filename=nil)
    @tmpcount += 1
    if filename
      Dir.mkdir("#{@tmpdir}/t#{@tmpcount}")
      return "#{@tmpdir}/t#{@tmpcount}/#{filename}"
    else
      return "#{@tmpdir}/t#{@tmpcount}"
    end
  end

  def setup_workdir(repository)
    open("#{@workdir}/CVS/Repository", "w") {|f| f.print(repository, "\n")}
    open("#{@workdir}/CVS/Entries", "w") {|f| f.print("D\n")}
    Dir.foreach(@workdir) {|f|
      next if /\A(\.\.|\.|CVS)\z/ =~ f
      File.unlink("#{@workdir}/#{f}")
    }
  end

  def run_cvs_internal(childproc, *args)
    command = ["cvs", "-f"] + args
    p command if $debug.include?(:command)
    child = fork {
      childproc.call if childproc
      Dir.chdir(@workdir)
      exec(*command)
    }
    result = yield if iterator?
    Process.waitpid(child, nil)
    raise CVSCommandFailure.new if $? != 0
    return result
  end

  def run_cvs_stderr(*args)
    result = nil
    r, w = IO.pipe
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(open("/dev/null"))
	STDERR.reopen(w)
	r.close
	w.close
      }, *args) {
      w.close
      result = yield(r)
      r.close
    }
    return result
  end

  def run_cvs_stdout_file(*args)
    tmpfile = self.tmpfilename
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(open(tmpfile, "w"))
      }, *args)
    return tmpfile
  end

  def run_cvs(*args)
    self.run_cvs_internal(nil, *args)
  end

  def getlogs(since=nil)
    args = ["-Q", "log"]
    args << "-d#{since}<" if since
    tmpfile = self.run_cvs_stdout_file(*args)
    return tmpfile
  end

  def getsubdirs
    result = []
    self.run_cvs_stderr("-Q", "update", "-r00", "-d", "-p", ".") {|f|
      f.each_line {|l| result << $1 if /cvs server: New directory `(.*)' -- ignored\n/ =~ l && /\A(?:\.|\.\.)\z/ != $1}
    }
    return result
  end

  def getrevision(rev, filename)
    # -kb is not suitable because it prevents delta transmission.
    self.run_cvs("-Q", "update", "-ko", "-r#{rev}", filename)
    return "#{@workdir}/#{filename}"
  end

  def cleanup
    system "/bin/rm", "-rf", @tmpdir
  end
end

DeltaInfo = Struct.new("DeltaInfo",
  :revision, :date, :author, :state, :branches, :log)

RCSInfo = Struct.new("RCSInfo",
  :rcs_file, :working_file, :head, :default_branch, :tags, :keyword_substitution, :description)

class CVSMirror
  def initialize(mirrordir, cvsroot, mod)
    @mirrordir = mirrordir
    @cvsroot = cvsroot
    @module = mod
    @work = CVSWork.new(@cvsroot)
    @lock = {}
  end

  def cleanup
    @work.cleanup
  end

  class LogFormatError < Exception
  end

  def parse_log(logfile)
    open(logfile) {|f|
      file_delimiter = "\n=============================================================================\n"
      delta_delimiter = /\n----------------------------\n/
      while l = f.gets(file_delimiter)
	if file_delimiter.length <= l.length && file_delimiter == l[l.length - file_delimiter.length, file_delimiter.length]
	  l[l.length - file_delimiter.length, file_delimiter.length] = "\n"
	end
        header, *deltas = l.split(delta_delimiter)
	header << "\n" if header !~ /\n\z/
	raise LogFormatError.new unless /^RCS file: (.*)\n/ =~ header; rcs_file = $1
	raise LogFormatError.new unless /^Working file: (.*)\n/ =~ header; working_file = $1
	raise LogFormatError.new if /\/|\A(?:\.\.|\.)\z/ =~ working_file 
	raise LogFormatError.new unless /^head: (.*)\n/ =~ header; head = $1
	/^branch: (.*)\n/ =~ header; default_branch = $1
	raise LogFormatError.new unless /^symbolic names:\n((?:\t.*\n)*)/ =~ header; symbolic_names = $1
	tags = symbolic_names.split(/\n/).collect! {|l| l.split(/[\s:]+/)[1,2]}
	raise LogFormatError.new unless /^keyword substitution: (.*)\n/ =~ header; keyword_substitution = $1
	raise LogFormatError.new unless /^description:\n/ =~ header; description = $'
	yield RCSInfo.new(rcs_file, working_file, head, default_branch, tags, keyword_substitution, description)
	deltas.each {|r|
	  raise LogFormatError.new unless /\Arevision ([.\d]*).*\n/ =~ r
	  revision = $1
	  r = $'
	  raise LogFormatError.new unless /\Adate: (\d+\/\d+\/\d+ \d+:\d+:\d+);  author: ([a-zA-Z0-9_\-]+);  state: (\w+);.*\n/ =~ r
	  date = $1
	  author = $2
	  state = $3
	  r = $'
	  if /\Abranches:\s*(.*);\n/ =~ r
	    r = $'
	    branches = $1.split(/;\s*/)
	  else
	    branches = []
	  end
	  log = r
	  yield DeltaInfo.new(revision, date, author, state, branches, log)
	}
	yield nil
      end
    }
  end

  def parse_rcsfile_log(rcsfile)
    tmprlog = @work.tmpfilename
    command = ["rlog", rcsfile]
    p command if $debug.include?(:command)
    child = fork {
      STDOUT.reopen(open(tmprlog, "w"))
      exec(*command)
    }
    Process.waitpid(child, nil)
    raise RCSCommandFailure.new if $? != 0
    parse_log(tmprlog) {|obj| yield obj}
    File.unlink(tmprlog)
  end

  def make_prefixdir(filename)
    filename = filename.clone
    if filename.sub!(/\/[^\/]*\z/, '')
      mkdir_recursive(filename)
    end
  end

  def mkdir_recursive(filename)
    return if FileTest.directory?(filename)
    begin
      Dir.mkdir(filename)
    rescue Errno::ENOENT
      mkdir_recursive(filename.sub(/\/[^\/]*\z/, ''))
      retry
    end
  end

  def find_rcs_file(relpath, working_file)
    local_rcsfile = @mirrordir + relpath + '/' + working_file + ',v'
    begin
      File.stat(local_rcsfile)
    rescue Errno::ENOENT
      local_rcsfile = @mirrordir + relpath + '/Attic/' + working_file + ',v'
      begin
	File.stat(local_rcsfile)
      rescue Errno::ENOENT
	local_rcsfile = nil
      end
    end
    return local_rcsfile
  end

  def master_lock(dir)
    mkdir_recursive(dir)
    n = 0
    begin
      Dir.mkdir("#{dir}/#cvs.lock")
    rescue Errno::EEXIST
      STDERR.print "master lock failed: #{dir}/\#cvs.lock\n"
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    end
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << '#cvs.lock'
  end

  def master_unlock(dir)
    Dir.rmdir("#{dir}/#cvs.lock")
    @lock[dir].delete('#cvs.lock') { raise InvalidUnlock.new }
  end

  def create_read_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_read_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def read_lock(dir)
    locked = false
    rlocked = false
    begin
      disable_interrupt {
	master_lock(dir); locked = true
	create_read_lock_file(dir); rlocked = true
	master_unlock(dir); locked = false
      }
      yield
    ensure
      delete_read_lock_file(dir) if rlocked
    end
  end

  def read_unlock(dir)
    rlockd = true
    begin
      delete_read_lock_file(dir); rlocked = false
      yield
    ensure
      disable_interrupt {
	master_lock(dir)
	create_read_lock_file(dir)
	master_unlock(dir)
      } unless rlocked
    end
  end

  def create_write_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_write_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def write_lock(dir)
    n = 0
    locked = false
    wlocked = false
    begin
      master_lock(dir); locked = true
      Dir.foreach(dir) {|f|
	next if @lock[dir].include?(f)
	if /\A\#cvs\.rfl/ =~ f
	  STDERR.print "read lock found: #{dir}/#{f}\n"
	  raise RetryLock.new
	end
      }
      create_write_lock_file(dir); wlocked = true
      yield
    rescue RetryLock
      master_unlock(dir); locked = false
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    ensure
      delete_write_lock_file(dir) if wlocked
      master_unlock(dir) if locked
    end
  end

  def disable_interrupt
    trap('INT', 'IGNORE')
    trap('TERM', 'IGNORE')
    if iterator?
      yield
      enable_interrupt
    end
  end

  def enable_interrupt
    trap('INT', 'DEFAULT')
    trap('TERM', 'DEFAULT')
  end

  def create_empty_file(filename)
    open(filename, "w") {}
  end

  def update(since=nil)
    queue = [""]
    while !queue.empty?
      relpath = queue.shift
      mod = @module + relpath
      @work.setup_workdir(mod)
      @work.getsubdirs.each {|subdir| queue << "#{relpath}/#{subdir}"}
      update_directory(relpath, since)
    end
  end

  def trunk?(rev)
    return /\A(\d+)\.(\d+)\z/ =~ rev
  end

  def checkinable?(local_revisions, rev)
    lock_rev = nil
    if local_revisions
      if /\A(\d+)\.(\d+)\z/ =~ rev
	reva = [$1.to_i, $2.to_i]
	# it's on a maintrunk.
	high_enough = true
	highest = nil
	local_revisions.each {|lrev|
	  if /\A(\d+)\.(\d+)\z/ =~ lrev
	    lreva = [$1.to_i, $2.to_i]
	    if (reva <=> lreva) <= 0
	      high_enough = false
	      break
	    end
	    if highest == nil || (highest <=> lreva) < 0
	      highest = lreva
	    end
	  end
	}
	return unless high_enough
	lock_rev = highest.join('.') if highest
      else
	# it's on a branch.
	#p rev
	branch = rev.sub(/\.\d+\z/, '')
	branchpoint = branch.sub(/\.\d+\z/, '')
	branch_regex = /\A#{Regexp.quote(branch + '.')}(\d+)\z/
	branch_rev = rev.sub(/\A.*\./, '').to_i
	branch_exist = false
	branchpoint_exist = false
	high_enough = true
	local_revisions.each {|lrev|
	  branchpoint_exist = true if lrev == branchpoint
	  if branch_regex =~ lrev
	    branch_exist = true
	    if branch_rev <= $1.to_i
	      high_enough = false
	      break
	    end
	  end
	}
	return unless high_enough && branchpoint_exist
	if branch_exist
	  lock_rev = branch
	else
	  lock_rev = nil
	end
      end
    else
      if /\A\d+\.\d+\z/ !~ rev 
	# the revision is not on a maintrunk.
	# non-maintrunk revision needs a branchpoint to check in.
	return
      end
    end
    yield lock_rev
  end

  def rcs_lock(rcsfile, lock_rev)
    command = ["rcs", "-q", "-l#{lock_rev}", rcsfile]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new if $? != 0
  end

  def checkin(rcsfile, rcsinfo, delta, tmpwork)
    tmpcidir = @work.tmpfilename
    Dir.mkdir(tmpcidir)
    tmpci = "#{tmpcidir}/#{rcsinfo.working_file}"
    if FileTest.exist?(tmpwork)
      system "/bin/cp", tmpwork, tmpci
    else
      create_empty_file tmpci
    end
    make_prefixdir(rcsfile)
    command = ["ci",
      "-q#{delta.revision}",
      "-f",
      "-d#{delta.date}",
      "-m" + (/\A\s*\z/ =~ delta.log ? '*** empty log message ***' : delta.log),
      "-t-#{rcsinfo.description}",
      "-s#{delta.state}",
      "-w#{delta.author}",
      rcsfile,
      tmpci]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new if $? != 0
    Dir.rmdir(tmpcidir)
  end

  def update_directory(relpath, since)
    rcsinfo = nil
    deltas = nil
    parse_log(@work.getlogs(since)) {|obj|
      case obj
      when RCSInfo
	rcsinfo = obj
	deltas = []
      when DeltaInfo
	deltas << obj
      when NilClass
        update_file(relpath, rcsinfo, deltas)
      else
	raise Error.new
      end
    }
  end

  def update_rcs_attributes(relpath, rcsfile, rcsinfo, local_rcsinfo)
    args = []
    if rcsinfo.default_branch != local_rcsinfo.default_branch
      args << "-b#{rcsinfo.default_branch}"
    end
    if rcsinfo.keyword_substitution != local_rcsinfo.keyword_substitution
      args << "-k#{rcsinfo.keyword_substitution}"
    end
    rcsinfo.tags.reverse_each{|sym, rev|
      if pair = local_rcsinfo.tags.assoc(sym)
	args << "-N#{sym}:#{rev}" if pair[1] != rev
      else
	args << "-n#{sym}:#{rev}"
      end
    }
    unless args.empty?
      args << rcsfile
      command = ["rcs", "-q"] + args
      p command if $debug.include?(:command)
      disable_interrupt {
	write_lock(@mirrordir + relpath) {
	  system *command
	  raise RCSCommandFailure.new if $? != 0
	}
      }
    end
  end

  def update_file(relpath, rcsinfo, deltas)
    deltas_hash = {}
    deltas.each {|delta|
      deltas_hash[delta.revision.split(/\./).collect! {|n| n.to_i}] = delta
    }
    deltas = deltas_hash.keys.sort.collect! {|key| deltas_hash[key]}

    tmpwork = nil
    local_rcsinfo = nil
    deltas_to_checkin = []
    lock_to_checkin = {}
    read_lock(@mirrordir + relpath) {
      local_revisions = []
      if local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	local_revisions = []
	self.parse_rcsfile_log(local_rcsfile) {|obj|
	  case obj
	  when RCSInfo
	    local_rcsinfo = obj
	  when DeltaInfo
	    local_revisions << obj.revision
	  end
	}
      end
      deltas.each {|delta|
	checkinable?(local_revisions, delta.revision) {|lock_rev|
	  lock_to_checkin[delta] = lock_rev
	  deltas_to_checkin << delta
	  local_revisions << delta.revision
	}
      }
      if !deltas_to_checkin.empty?
	read_unlock(@mirrordir + relpath) {
	  deltas_to_checkin.each {|delta|
	    tmpwork = update_delta(relpath, rcsinfo, delta, lock_to_checkin[delta]) || tmpwork
	  }
	}
	if local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	  parse_rcsfile_log(local_rcsfile) {|obj|
	    local_rcsinfo = obj if obj.kind_of?(RCSInfo)
	  }
	end
      end

      if local_rcsfile
	update_rcs_attributes(relpath, local_rcsfile, rcsinfo, local_rcsinfo)
      end
    }

    begin
      File.unlink(tmpwork)
    rescue Errno::ENOENT
    end if tmpwork
  end

  def update_delta(relpath, rcsinfo, delta, lock)
    tmpwork = nil
    target = nil
    if delta.state == 'dead'
      # xxx: /dev/null is not correct.  it should point to the previous revision checkouted from local rcsfile.
      target = '/dev/null'
    else
      target = tmpwork = @work.getrevision(delta.revision, rcsinfo.working_file)
    end

    disable_interrupt {
      write_lock(@mirrordir + relpath) {
	local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	unless local_rcsfile
	  if delta.state == 'dead'
	    local_rcsfile = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	  else
	    local_rcsfile = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	  end
	end

	rcs_lock(local_rcsfile, lock) if lock && FileTest.exist?(local_rcsfile)
	checkin(local_rcsfile, rcsinfo, delta, target)

	if trunk?(delta.revision)
	  if delta.state == 'dead'
	    local_rcsfile_new = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	  else
	    local_rcsfile_new = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	  end
	  if local_rcsfile != local_rcsfile_new
	    make_prefixdir(local_rcsfile_new)
	    print "rename: #{local_rcsfile} -> #{local_rcsfile_new}\n" if $debug.include?(:attic)
	    File.rename(local_rcsfile, local_rcsfile_new)
	  end
	end
      }
    }
    return tmpwork
  end

end

$debug = []
$debug = [:command, :attic]

c = CVSMirror.new(ARGV[0], ARGV[1], ARGV[2])
c.update
c.cleanup
