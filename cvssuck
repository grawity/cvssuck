#!/usr/local/bin/ruby

# CVSsuck - cvs repository retrieving tool via cvs client/server protocol

# usage:
#
# % cvssuck [-s] [-t] [-o output-directory] cvsroot module
# 
# -s : skeleton mode
# -t : translation mode

# example:
#
# % cvssuck :pserver:anonymous@cvs.m17n.org:/cvs/cvs cvssuck

# author:
#  Tanaka Akira <akr@m17n.org>

require 'parsearg'
require 'socket' # to use gethostname
require 'fcntl'

class Set<Hash
  def Set.[](*objs)
    s = Set.new
    objs.each {|o| s << o}
    return s
  end

  def <<(obj)
    self[obj] = true
  end
end

class LogFormatError<Exception
end

class LockFailure<Exception
end

class CouldNotLock<Exception
end

class RetryLock<Exception
end

class InvalidUnlock<Exception
end

class CVSCommandFailure<Exception
  def initialize(status)
    super("status: #{status}")
  end
end

class RCSCommandFailure<Exception
  def initialize(status)
    super("status: #{status}")
  end
end

class TempDir
  def initialize(keyword="cvssuck")
    @count = 0
    @top = "/tmp/#{keyword}-#{$$}"
    Dir.mkdir(@top, 0755)
    @dirs = []
    @allocated = {}
  end

  def genname
    begin
      @count += 1
    end while @allocated.include?(name = "#{@top}/t#{@count}")

    @allocated[name] = true
    return name
  end

  def alloc(basename=nil)
    if basename
      @dirs.each {|d|
	unless @allocated.include?(name = "#{d}/#{basename}")
	  @allocated[name] = true
	  return name
	end
      }
      d = genname
      Dir.mkdir(d, 0755)
      @dirs << d
      name = "#{d}/#{basename}"
      @allocated[name] = true
      return name
    else
      return genname
    end
  end

  def free(name)
    raise Error.new unless @allocated.delete(name)
    if FileTest.exist?(name)
      system "/bin/rm", "-rf", name
    end
  end

  def cleanup
    system "/bin/rm", "-rf", @top
  end
end

class Revision
  def initialize(str)
    raise Error.new unless /\A\d+(?:\.\d+)*\z/ =~ str
    @str = str
    @arr = str.split(/\./); @arr.collect! {|n| n.to_i}
  end

  def to_s
    return @str
  end

  attr_reader :arr

  def <=>(other)
    result = @arr.length <=> other.arr.length
    result = @arr <=> other.arr if result == 0
    return result
  end

  def ==(other)
    return false unless other.kind_of?(Revision)
    return (self <=> other) == 0
  end

  def <(other)
    return (self <=> other) < 0
  end

  def >(other)
    return (self <=> other) > 0
  end

  def <=(other)
    return (self <=> other) <= 0
  end

  def >=(other)
    return (self <=> other) >= 0
  end

  def hash
    return @arr.hash
  end

  def eql?(other)
    return self == other
  end

  def trunk?
    return @arr.length == 2
  end

  def branch?
    return (@arr.length & 1) == 1
  end

  def magic_branch?
    return (@arr.length & 1) == 0 && 4 <= @arr.length && @arr[-2] == 0
  end

  def on?(br)
    return br.branch? && @arr.length == br.arr.length + 1 && @arr[0, @arr.length - 1] == br.arr
  end

  def same_branch?(other)
    return (@arr.length == other.arr.length) && (trunk? || (@arr[0, @arr.length - 1] == other.arr[0, @arr.length - 1]))
  end

  def branch
    raise Error.new if branch?
    return Revision.new(@str.sub(/\.\d+\z/, ''))
  end

  def branch_point
    raise Error.new if branch?
    return Revision.new(@str.sub(/\.\d+\.\d+\z/, ''))
  end

end

class RevisionSet
  def initialize(revs=[])
    @revs = {}
    @head = {}
    revs.each {|r| self << r}
  end

  def <<(rev)
    @revs[rev] = true
    b = rev.trunk? ? nil : rev.branch
    @head[b] = rev if !@head.key?(b) || @head[b] < rev
  end

  def include?(rev)
    return @revs.include?(rev)
  end

  def checkinable?(rev)
    return if rev.branch?
    if rev.trunk?
      b = nil
      if @head.key?(b)
        yield @head[b] if @head[b] < rev
      else
        yield nil
      end
    else
      b = rev.branch
      if @head.key?(b)
        yield @head[b] if @head[b] < rev
      else
        yield nil if @revs.include?(rev.branch_point)
      end
    end
  end
end

class DeltaInfo
  attr_reader :revision, :date, :author, :state, :branches, :log
  def initialize(revision, date, author, state, branches, log)
    @author = author
    @branches = branches
    @date = date
    @log = log
    @revision = revision
    @state = state
  end

  def attic?(rcsinfo=nil)
    return true if rcsinfo && @revision == rcsinfo.head && rcsinfo.attic?
    return @state == 'dead'
  end
end

class RCSInfo
  attr_reader :rcs_file, :working_file, :head, :default_branch, :tags, :keyword_substitution, :description
  def initialize(rcs_file, working_file, head, default_branch, tags, keyword_substitution, description)
    @default_branch = default_branch
    @description = description
    @head = head
    @keyword_substitution = keyword_substitution
    @rcs_file = rcs_file
    @tags = tags
    @working_file = working_file
  end

  def attic?
    return /\/Attic\/[^\/]+\z/ =~ @rcs_file
  end
end

class RCSLog
  def RCSLog.parse_log(logfile)
    open(logfile) {|f|
      file_delimiter = "\n=============================================================================\n"
      delta_delimiter = /\n----------------------------\n/
      while l = f.gets(file_delimiter)
	if file_delimiter.length <= l.length && file_delimiter == l[l.length - file_delimiter.length, file_delimiter.length]
	  l[l.length - file_delimiter.length, file_delimiter.length] = "\n"
	end
        header, *deltas = l.split(delta_delimiter)
	header << "\n" if header !~ /\n\z/
	raise LogFormatError.new unless /^RCS file: (.*)\n/ =~ header; rcs_file = $1
	raise LogFormatError.new unless /^Working file: (.*)\n/ =~ header; working_file = $1
	raise LogFormatError.new if /\/|\A(?:\.\.|\.)\z/ =~ working_file 
	raise LogFormatError.new unless /^head: (.*)\n/ =~ header; head = $1
	/^branch: (.*)\n/ =~ header; default_branch = $1
	raise LogFormatError.new unless /^symbolic names:\n((?:\t.*\n)*)/ =~ header; symbolic_names = $1
	tags = symbolic_names.split(/\n/).collect! {|l| l.split(/[\s:]+/)[1,2]}
	raise LogFormatError.new unless /^keyword substitution: (.*)\n/ =~ header; keyword_substitution = $1
	if /^description:\n/ =~ header; description = $'; else description = nil; end
	yield RCSInfo.new(
	  rcs_file,
	  working_file,
	  Revision.new(head),
	  default_branch ? Revision.new(default_branch) : nil,
	  tags.collect! {|sym, rev| [sym, Revision.new(rev)]},
	  keyword_substitution,
	  description)
	deltas.each {|r|
	  raise LogFormatError.new unless /\Arevision ([.\d]*).*\n/ =~ r
	  revision = $1
	  r = $'
	  raise LogFormatError.new unless /\Adate: (\d+\/\d+\/\d+ \d+:\d+:\d+);  author: ([a-zA-Z0-9_\-]+);  state: (\w+);.*\n/ =~ r
	  date = $1
	  author = $2
	  state = $3
	  r = $'
	  if /\Abranches:\s*(.*);\n/ =~ r
	    r = $'
	    branches = $1.split(/;\s*/)
	  else
	    branches = []
	  end
	  log = r
	  yield DeltaInfo.new(
	    Revision.new(revision),
	    date,
	    author,
	    state,
	    branches.collect! {|b| Revision.new(b)},
	    log)
	}
	yield nil
      end
    }
  end
end

class CVSWork
  def initialize(cvsroot, tmpdir)
    @tmpdir = tmpdir
    @workdir = @tmpdir.genname
    Dir.mkdir(@workdir)
    Dir.mkdir("#{@workdir}/CVS")
    open("#{@workdir}/CVS/Root", "w") {|f| f.print(cvsroot, "\n")}
    @cache_filename = nil
    @cache_path = nil
  end

  def setup_workdir(repository)
    discard_cache
    @repository = repository
    open("#{@workdir}/CVS/Repository", "w") {|f| f.print(repository, "\n")}
    open("#{@workdir}/CVS/Entries", "w") {|f| f.print("D\n")}
    Dir.foreach(@workdir) {|f|
      next if /\A(\.\.|\.|CVS)\z/ =~ f
      File.unlink("#{@workdir}/#{f}")
    }
  end

  def run_cvs_internal(*args)
    command = ['cvs', '-f']
    command << '-z3' unless $debug.include?(:protocollog)
    command += args
    p command if $debug.include?(:command)
    begin
      tmpbase = @tmpdir.alloc
      tmpout = "#{tmpbase}.stdout"
      tmperr = "#{tmpbase}.stderr"
      child = fork {
	ENV['CVS_CLIENT_LOG'] = tmpbase if $debug.include?(:protocollog)
	STDOUT.reopen(open(tmpout, "w"))
	STDERR.reopen(open(tmperr, "w"))
	Dir.chdir(@workdir)
	exec(*command)
      }
      Process.waitpid(child, nil)
      yield $?, tmpout, tmperr
    ensure
      File.unlink(tmpout) if !$debug.include?(:cvsout) && FileTest.exist?(tmpout)
      File.unlink(tmperr) if !$debug.include?(:cvsout) && FileTest.exist?(tmperr)
      @tmpdir.free(tmpbase)
    end
  end

  def run_cvs_stderr(*args)
    result = nil
    run_cvs_internal(*args) {|status, out, err|
      raise CVSCommandFailure.new(status) if status != 0
      open(err, 'r') {|f| result = yield f}
    }
    return result
  end

  def run_cvs(*args)
    run_cvs_internal(*args) {|status, out, err|
      raise CVSCommandFailure.new(status) if status != 0
    }
  end

  def grepfile(filename, pat)
    open(filename, 'r') {|f|
      f.each {|l|
        return l if pat =~ l
      }
    }
    return nil
  end

  def parselogs(since=nil)
    tmpfile = nil
    args = ["log"]
    args << "-d#{since}<" if since
    run_cvs_internal(*args) {|status, out, err|
      if status == 256 && (line = grepfile(err, / nothing known about /))
        STDERR.print "warning: `cvs log' in #{@repository} is failed with a message `#{line.chomp}'\n"
      else
	raise CVSCommandFailure.new(status) if status != 0
      end
      RCSLog.parse_log(out) {|obj| yield obj}
    }
  end

  def getsubdirs
    result = []
    self.run_cvs_stderr("update", "-r00", "-d", "-p", ".") {|f|
      f.each_line {|l|
        result << $1 if /cvs server: New directory `(.*)' -- ignored\n/ =~ l && /\A(?:\.|\.\.)\z/ != $1
      }
    }
    return result
  end

  def getrevision(filename, rev)
    discard_cache if @cache_filename != filename
    # -kb is not suitable because it prevents delta transmission.
    self.run_cvs("update", "-ko", "-r#{rev}", filename)
    @cache_filename = filename
    @cache_path = "#{@workdir}/#{filename}"
    return @cache_path
  end

  def discard_cache
    if @cache_filename
      File.unlink(@cache_path)
      @cache_filename = nil
      @cache_path = nil
    end
  end

  def cleanup
    discard_cache
  end
end

class LocalRepository
  def initialize(tmpdir, topdir, lockdir=nil)
    @tmpdir = tmpdir
    @topdir = topdir
    @lockdir = lockdir || topdir
    # xxx: "#{topdir}/CVSROOT/config" should be examined.
    # xxx: Maybe, ancestors of topdir as well.
    @lockstate = {}
    @info = ".#{Socket.gethostname}.#{$$}"
  end

  def rcs_file(relpath, name, dead=false)
    if dead
      return @topdir + relpath + '/Attic/' + name + ',v'
    else
      return @topdir + relpath + '/' + name + ',v'
    end
  end

  def each_rcs_file(relpath, name)
    yield rcs_file(relpath, name, false)
    yield rcs_file(relpath, name, true)
  end

  def find_rcs_file(relpath, name)
    each_rcs_file(relpath, name) {|local_rcsfile|
      begin
	File.stat(local_rcsfile)
	return local_rcsfile
      rescue Errno::ENOENT
      end
    }
    return nil
  end

  def make_prefixdir(filename)
    filename = filename.clone
    if filename.sub!(/\/[^\/]*\z/, '')
      mkdir_recursive(filename)
    end
  end

  def mkdir_recursive(filename)
    return if FileTest.directory?(filename)
    begin
      Dir.mkdir(filename)
    rescue Errno::ENOENT
      mkdir_recursive(filename.sub(/\/[^\/]*\z/, ''))
      retry
    end
  end

  # locking interfaces:
  #
  # * read_lock(relpath) {...} 
  # * read_unlock(relpath) {...} - can be used only in `read_lock'.
  # * write_lock(relpath) {...}

  # for each directory, there are three states:
  #
  # * unlocked     - read_lock   -> read locked.
  #                - read_unlock -> forbidden.
  #                - write_lock  -> write locked.
  # * read locked  - read_lock   -> read locked.
  #                - read_unlock -> unlocked.
  #                - write_lock  -> write locked.
  # * write locked - read_lock   -> write locked.
  #                - read_unlock -> forbidden.
  #                - write_lock  -> write locked.

  def disable_interrupt
    trap('INT', 'IGNORE')
    trap('TERM', 'IGNORE')
    if iterator?
      yield
      enable_interrupt
    end
  end

  def enable_interrupt
    trap('INT', 'DEFAULT')
    trap('TERM', 'DEFAULT')
  end

  def try_lock(relpath)
    n = 0
    begin
      disable_interrupt
      yield
    rescue LockFailure
      enable_interrupt
      n += 1
      if n == 10
	STDERR.print "give up to lock #{@topdir + relpath}.\n"
	raise
      end
      secs = 45 + rand(30)
      STDERR.print "failed to lock #{@topdir + relpath} (#{n} times). wait #{secs} seconds...\n"
      sleep secs
      retry
    end
  end

  def create_lock_directory(filename)
    begin
      make_prefixdir(filename)
      Dir.mkdir(filename)
    rescue Exception
      raise LockFailure.new(filename)
    end
  end

  def delete_lock_directory(filename)
    Dir.rmdir(filename)
  end

  def create_lock_file(filename)
    begin
      make_prefixdir(filename)
      File.open(filename, Fcntl::O_CREAT | Fcntl::O_EXCL | Fcntl::O_WRONLY) {}
    rescue Exception
      raise LockFailure.new(filename)
    end
  end

  def delete_lock_file(filename)
    File.unlink(filename)
  end

  def master_lock_file(relpath)
    return "#{@lockdir}#{relpath}/\#cvs.lock"
  end

  def create_master_lock(relpath)
    create_lock_directory(master_lock_file(relpath))
  end

  def delete_master_lock(relpath)
    delete_lock_directory(master_lock_file(relpath))
  end

  def read_lock_file(relpath)
    return "#{@lockdir}#{relpath}/\#cvs.rfl#{@info}"
  end

  def create_read_lock(relpath)
    create_lock_file(read_lock_file(relpath))
  end

  def delete_read_lock(relpath)
    delete_lock_file(read_lock_file(relpath))
  end

  def write_lock_file(relpath)
    return "#{@lockdir}#{relpath}/\#cvs.wfl#{@info}"
  end

  def create_write_lock(relpath)
    create_lock_file(write_lock_file(relpath))
  end

  def delete_write_lock(relpath)
    delete_lock_file(write_lock_file(relpath))
  end

  def check_read_lock(relpath)
    dir = "#{@lockdir}#{relpath}"
    Dir.foreach(dir) {|f|
      if /\A\#cvs\.rfl/ =~ f
	next if $' == @info
        raise LockFailure.new(dir)
      end
    }
  end

  def master_lock(relpath)
    create_master_lock(relpath)
    begin
      yield
    ensure
      delete_master_lock(relpath)
    end
  end

  def read_lock(relpath)
    if (@lockstate[relpath] ||= 'u') != 'u'
      yield
    else
      try_lock(relpath) {
	master_lock(relpath) {
	  create_read_lock(relpath)
	}
	@lockstate[relpath] = 'r'
      }
      begin
        enable_interrupt
	yield
      ensure
	disable_interrupt {
	  delete_read_lock(relpath)
	  @lockstate[relpath] = 'u'
	}
      end
    end
  end

  def read_unlock(relpath)
    if (@lockstate[relpath] ||= 'u') != 'r'
      raise InvalidUnlock.new
    else
      disable_interrupt
      delete_read_lock(relpath)
      @lockstate[relpath] = 'u'
      begin
        enable_interrupt
	yield
      ensure
	try_lock(relpath) {
	  master_lock(relpath) {
	    create_read_lock(relpath)
	  }
	  @lockstate[relpath] = 'r'
	}
	enable_interrupt
      end
    end
  end

  def write_lock(relpath)
    if (@lockstate[relpath] ||= 'u') == 'w'
      yield
    else
      old_lock = @lockstate[relpath]
      try_lock(relpath) {
	create_master_lock(relpath)
	begin
	  check_read_lock(relpath)
	  create_write_lock(relpath)
	rescue LockFailure
	  delete_master_lock(relpath)
	  raise
	end
	@lockstate[relpath] = 'w'
      }
      begin
	yield
      ensure
	delete_write_lock(relpath)
	delete_master_lock(relpath)
	@lockstate[relpath] = old_lock
        enable_interrupt
      end
    end
  end

  def rcs_lock(rcsfile, lock_rev)
    command = ["rcs", "-q", "-l#{lock_rev}", rcsfile]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new($?) if $? != 0
  end

  def checkin(rcsfile, rcsinfo, delta, filename)
    tmpci = @tmpdir.alloc(rcsinfo.working_file)
    if FileTest.exist?(filename)
      system "/bin/cp", filename, tmpci
    else
      open(tmpci, "w") {}
    end
    make_prefixdir(rcsfile)
    command = ["ci",
      "-q#{delta.revision}",
      "-f",
      "-d#{delta.date}",
      "-m" + (/\A\s*\z/ =~ delta.log ? '*** empty log message ***' : delta.log),
      "-t-#{rcsinfo.description}",
      "-s#{delta.state}",
      "-w#{delta.author}",
      rcsfile,
      tmpci]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new($?) if $? != 0
    @tmpdir.free(tmpci)
  end

  def update_rcs_attributes(relpath, rcsfile, rcsinfo, local_rcsinfo)
    args = []
    if rcsinfo.default_branch != local_rcsinfo.default_branch
      args << "-b#{rcsinfo.default_branch}"
    end
    if rcsinfo.keyword_substitution != local_rcsinfo.keyword_substitution
      args << "-k#{rcsinfo.keyword_substitution}"
    end
    rcsinfo.tags.reverse_each{|sym, rev|
      if pair = local_rcsinfo.tags.assoc(sym)
	args << "-N#{sym}:#{rev}" if pair[1] != rev
      else
	args << "-n#{sym}:#{rev}"
      end
    }
    unless args.empty?
      args << rcsfile
      command = ["rcs", "-q"] + args
      p command if $debug.include?(:command)
      write_lock(relpath) {
	system *command
	raise RCSCommandFailure.new($?) if $? != 0
      }
    end
  end

  def adjust_attic(relpath, name, in_attic, local_rcsfile=nil)
    local_rcsfile = find_rcs_file(relpath, name) unless local_rcsfile
    local_rcsfile_new = rcs_file(relpath, name, in_attic)
    if local_rcsfile != local_rcsfile_new
      make_prefixdir(local_rcsfile_new)
      print "rename #{local_rcsfile} -> #{local_rcsfile_new}\n" if $debug.include?(:attic)
      File.rename(local_rcsfile, local_rcsfile_new)
    end
  end

  def parse_rcsfile_log(rcsfile)
    tmprlog = @tmpdir.genname
    command = ["rlog", rcsfile]
    p command if $debug.include?(:command)
    child = fork {
      STDOUT.reopen(open(tmprlog, "w"))
      exec(*command)
    }
    Process.waitpid(child, nil)
    raise RCSCommandFailure.new($?) if $? != 0
    RCSLog.parse_log(tmprlog) {|obj| yield obj}
    File.unlink(tmprlog)
  end

end

class CVSMirror
  def initialize(remote_cvsroot, filter, local_top, lockdir=nil)
    @tmpdir = TempDir.new
    @repository = LocalRepository.new(@tmpdir, local_top, lockdir)
    @work = CVSWork.new(remote_cvsroot, @tmpdir)
    @filter = filter
  end

  def cleanup
    @work.cleanup
    @tmpdir.cleanup
  end

  def update_module(remote_top, since=nil)
    queue = [""]
    while !queue.empty?
      relpath = queue.shift
      @work.setup_workdir(remote_top + relpath)
      @work.getsubdirs.each {|subdir| queue << "#{relpath}/#{subdir}"}
      update_directory(relpath, since)
    end
  end

  def update_directory(relpath, since)
    rcsinfo = nil
    deltas = nil
    @work.parselogs(since) {|obj|
      case obj
      when RCSInfo
	rcsinfo = obj
	deltas = []
      when DeltaInfo
	deltas << obj
      when NilClass
        update_file(relpath, rcsinfo, deltas)
      else
	raise Error.new
      end
    }
  end

  def update_file(relpath, rcsinfo, deltas)
    deltas = deltas.sort {|a, b| a.revision <=> b.revision}

    local_rcsinfo = nil
    deltas_to_checkin = []
    lock_to_checkin = {}
    @repository.read_lock(relpath) {
      p "planning begin #{tbeg = Time.now}" if $debug.include?(:hotspot)
      local_revisions = RevisionSet.new
      if local_rcsfile = @repository.find_rcs_file(relpath, rcsinfo.working_file)
	@repository.parse_rcsfile_log(local_rcsfile) {|obj|
	  case obj
	  when RCSInfo
	    local_rcsinfo = obj
	  when DeltaInfo
	    local_revisions << obj.revision
	  end
	}
      end
      revs = Set[*@filter.filter(rcsinfo, deltas)]
      p "planning mid #{tmid = Time.now} #{tmid - tbeg}" if $debug.include?(:hotspot)
      deltas.each {|delta|
	if revs.include?(delta.revision)
	  local_revisions.checkinable?(delta.revision) {|lock_rev|
	    lock_to_checkin[delta] = lock_rev
	    deltas_to_checkin << delta
	    local_revisions << delta.revision
	  }
	end
      }
      p "planning end #{tend = Time.now} #{tend - tbeg}" if $debug.include?(:hotspot)
      if !deltas_to_checkin.empty?
	@repository.read_unlock(relpath) {
	  deltas_to_checkin.each {|delta|
	    update_delta(relpath, rcsinfo, delta, lock_to_checkin[delta])
	  }
	}
	if local_rcsfile = @repository.find_rcs_file(relpath, rcsinfo.working_file)
	  @repository.parse_rcsfile_log(local_rcsfile) {|obj|
	    local_rcsinfo = obj if obj.kind_of?(RCSInfo)
	  }
	end
      end

      if local_rcsfile
	@repository.update_rcs_attributes(relpath, local_rcsfile, rcsinfo, local_rcsinfo)
      end
    }
  end

  def update_delta(relpath, rcsinfo, delta, lock)
    target = nil
    if delta.state == 'dead'
      # xxx: /dev/null is not correct.  it should point to the previous revision checkouted from local rcsfile.
      target = '/dev/null'
    else
      target = @work.getrevision(rcsinfo.working_file, delta.revision)
    end

    @repository.write_lock(relpath) {
      local_rcsfile = @repository.find_rcs_file(relpath, rcsinfo.working_file)
      unless local_rcsfile
	local_rcsfile = @repository.rcs_file(relpath, rcsinfo.working_file, delta.attic?(rcsinfo))
      end

      @repository.rcs_lock(local_rcsfile, lock) if lock && FileTest.exist?(local_rcsfile)
      @repository.checkin(local_rcsfile, rcsinfo, delta, target)
      # xxx: unlock if checkin is failed.

      if delta.revision.trunk?
	@repository.adjust_attic(relpath, rcsinfo.working_file, delta.attic?(rcsinfo), local_rcsfile)
      end
    }
  end

end

module Filter
  class All
    def filter(rcsinfo, deltas)
      revs = deltas.clone
      revs.collect! {|d| d.revision}
      return revs
    end
  end

  class Skeleton
    def filter(rcsinfo, deltas)
      revs = deltas.clone
      revs.collect! {|d| d.revision}
      revs.sort!

      result = []
      r1 = nil
      revs.each {|r2|
	if r1 && !r1.same_branch?(r2)
	  result << r1
	  result << r2.branch_point unless r2.trunk?
	end
	r1 = r2
      }
      if 0 < revs.length
        result << revs[0]
        result << revs[-1]
      end
      if revs.include?(r = Revision.new("1.1"))
	# 1.1 is important because it is a branch point of vendor branches.
        result << r
      end
      rcsinfo.tags.each {|s, r|
        if r.magic_branch?
	  result << r.branch_point
	elsif !r.branch?
	  result << r
	end
      }
      result.sort!
      result.uniq!
      return result
    end

  end
end

def usage
  STDERR.print <<'End'
usage: cvssuck [options] cvsroot module
option: -h : print help message
        -s : grab only root, branchpoint, tagged revision and heads of branches.
	-o output-directory : specify output directory. (default: module)
End
  exit 1
end

def main
  $USAGE='usage'

  $debug = []
  $debug = [:command, :attic, :cvsout]
  #$debug = [:command, :attic, :protocollog, :cvsout]

  parseArgs(2, nil, 'hs', 'o:')
  usage if 2 < ARGV.length

  usage if $OPT_h

  cvsroot = ARGV[0]
  mod = ARGV[1]
  topdir = $OPT_o || mod

  filter = $OPT_s ? Filter::Skeleton.new : Filter::All.new

  c = CVSMirror.new(cvsroot, filter, topdir)
  c.update_module(mod)
  c.cleanup
end

main
