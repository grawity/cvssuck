#!/usr/local/bin/ruby

# CVSsuck - cvs repository retrieving tool via cvs client/server protocol

# author:
#  Tanaka Akira <akr@m17n.org>

require "socket" # to use gethostname

class LogFormatError<Exception
end

class CouldNotLock<Exception
end

class RetryLock<Exception
end

class InvalidUnlock<Exception
end

class CVSCommandFailure<Exception
end

class RCSCommandFailure<Exception
end

class Tempdir
  def initialize(keyword="cvssuck")
    @count = 0
    @top = "/tmp/#{keyword}-#{$$}"
    Dir.mkdir(@top, 0755)
    @dirs = [@top]
    @allocated = {}
  end

  def genname
    @count += 1 while @allocated.include?(name = "#{@top}/t#{@count}")
    @allocated[name] = true
    return name
  end

  def alloc(basename=nil)
    if basename
      @dirs.each {|d|
	unless @allocated.include?(name = "#{d}/#{basename}")
	  @allocated[name] = true
	  return name
	end
      }
      d = genname
      Dir.mkdir(d, 0755)
      @dirs << d
      name = "#{d}/#{basename}"
      @allocated[name] = true
      return name
    else
      return genname
    end
  end

  def free(name)
    raise Error.new unless @allocated.delete(name)
    if FileTest.exist?(name)
      system "/bin/rm", "-rf", name
    end
  end

  def cleanup
    system "/bin/rm", "-rf", @top
  end
end

class Revision
  def initialize(str)
    raise Error.new unless /\A\d+(?:\.\d+)*\z/ =~ str
    @str = str
    @arr = str.split(/\./); @arr.collect! {|n| n.to_i}
  end

  def to_s
    return @str
  end

  attr_reader :arr

  def <=>(other)
    result = @arr.length <=> other.arr.length
    result = @arr <=> other.arr if result == 0
    return result
  end

  def ==(other)
    return false unless other.kind_of?(Revision)
    return (self <=> other) == 0
  end

  def <(other)
    return (self <=> other) < 0
  end

  def trunk?
    return @arr.length == 2
  end

  def branch?
    return (@arr.length & 1) == 1
  end

  def magic_branch?
    return (@arr.length & 1) == 0 && 4 <= @arr.length && @arr[-2] == 0
  end

  def on?(br)
    return br.branch? && @arr.length == br.arr.length + 1 && @arr[0, @arr.length - 1] == br.arr
  end

  def branch
    raise Error.new if branch?
    return Revision.new(@str.sub(/\.\d+\z/, ''))
  end

  def branch_point
    raise Error.new if branch?
    return Revision.new(@str.sub(/\.\d+\.\d+\z/, ''))
  end

  def checkinable?(local_revisions)
    return if branch?
    if trunk?
      revs = []
      local_revisions.each {|lrev| revs << lrev if lrev.trunk?}
      revs.sort!
      if revs.empty?
        yield nil
      elsif revs[-1] < self
	yield revs[-1]
      end
    else
      br = branch
      revs = []
      local_revisions.each {|lrev| revs << lrev if lrev.on?(br)}
      revs.sort!
      if revs.empty?
	if local_revisions.include?(branch_point)
	  yield nil
	end
      elsif revs[-1] < self
	yield revs[-1]
      end
    end
  end

end

class CVSWork
  def initialize(cvsroot, tmpdir)
    @tmpdir = tmpdir
    @workdir = @tmpdir.genname
    Dir.mkdir(@workdir)
    Dir.mkdir("#{@workdir}/CVS")
    open("#{@workdir}/CVS/Root", "w") {|f| f.print(cvsroot, "\n")}
  end

  def setup_workdir(repository)
    open("#{@workdir}/CVS/Repository", "w") {|f| f.print(repository, "\n")}
    open("#{@workdir}/CVS/Entries", "w") {|f| f.print("D\n")}
    Dir.foreach(@workdir) {|f|
      next if /\A(\.\.|\.|CVS)\z/ =~ f
      File.unlink("#{@workdir}/#{f}")
    }
  end

  def run_cvs_internal(childproc, *args)
    command = ["cvs", "-f"] + args
    p command if $debug.include?(:command)
    child = fork {
      childproc.call if childproc
      Dir.chdir(@workdir)
      exec(*command)
    }
    result = yield if iterator?
    Process.waitpid(child, nil)
    raise CVSCommandFailure.new if $? != 0
    return result
  end

  def run_cvs_stderr(*args)
    result = nil
    r, w = IO.pipe
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(open("/dev/null"))
	STDERR.reopen(w)
	r.close
	w.close
      }, *args) {
      w.close
      result = yield(r)
      r.close
    }
    return result
  end

  def run_cvs_stdout_file(*args)
    tmpfile = @tmpdir.genname
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(open(tmpfile, "w"))
      }, *args)
    return tmpfile
  end

  def run_cvs(*args)
    self.run_cvs_internal(nil, *args)
  end

  def getlogs(since=nil)
    args = ["-Q", "log"]
    args << "-d#{since}<" if since
    tmpfile = self.run_cvs_stdout_file(*args)
    return tmpfile
  end

  def getsubdirs
    result = []
    self.run_cvs_stderr("-Q", "update", "-r00", "-d", "-p", ".") {|f|
      f.each_line {|l| result << $1 if /cvs server: New directory `(.*)' -- ignored\n/ =~ l && /\A(?:\.|\.\.)\z/ != $1}
    }
    return result
  end

  def getrevision(rev, filename)
    # -kb is not suitable because it prevents delta transmission.
    self.run_cvs("-Q", "update", "-ko", "-r#{rev}", filename)
    return "#{@workdir}/#{filename}"
  end

  def cleanup
  end
end

DeltaInfo = Struct.new("DeltaInfo",
  :revision, :date, :author, :state, :branches, :log)

RCSInfo = Struct.new("RCSInfo",
  :rcs_file, :working_file, :head, :default_branch, :tags, :keyword_substitution, :description)

class CVSMirror
  def initialize(mirrordir, cvsroot, mod)
    @tmpdir = Tempdir.new
    @mirrordir = mirrordir
    @cvsroot = cvsroot
    @module = mod
    @work = CVSWork.new(@cvsroot, @tmpdir)
    @lock = {}
    @hostname = Socket.gethostname
  end

  def cleanup
    @work.cleanup
    @tmpdir.cleanup
  end

  def parse_log(logfile)
    open(logfile) {|f|
      file_delimiter = "\n=============================================================================\n"
      delta_delimiter = /\n----------------------------\n/
      while l = f.gets(file_delimiter)
	if file_delimiter.length <= l.length && file_delimiter == l[l.length - file_delimiter.length, file_delimiter.length]
	  l[l.length - file_delimiter.length, file_delimiter.length] = "\n"
	end
        header, *deltas = l.split(delta_delimiter)
	header << "\n" if header !~ /\n\z/
	raise LogFormatError.new unless /^RCS file: (.*)\n/ =~ header; rcs_file = $1
	raise LogFormatError.new unless /^Working file: (.*)\n/ =~ header; working_file = $1
	raise LogFormatError.new if /\/|\A(?:\.\.|\.)\z/ =~ working_file 
	raise LogFormatError.new unless /^head: (.*)\n/ =~ header; head = $1
	/^branch: (.*)\n/ =~ header; default_branch = $1
	raise LogFormatError.new unless /^symbolic names:\n((?:\t.*\n)*)/ =~ header; symbolic_names = $1
	tags = symbolic_names.split(/\n/).collect! {|l| l.split(/[\s:]+/)[1,2]}
	raise LogFormatError.new unless /^keyword substitution: (.*)\n/ =~ header; keyword_substitution = $1
	raise LogFormatError.new unless /^description:\n/ =~ header; description = $'
	yield RCSInfo.new(
	  rcs_file,
	  working_file,
	  Revision.new(head),
	  default_branch ? Revision.new(default_branch) : nil,
	  tags.collect! {|sym, rev| [sym, Revision.new(rev)]},
	  keyword_substitution,
	  description)
	deltas.each {|r|
	  raise LogFormatError.new unless /\Arevision ([.\d]*).*\n/ =~ r
	  revision = $1
	  r = $'
	  raise LogFormatError.new unless /\Adate: (\d+\/\d+\/\d+ \d+:\d+:\d+);  author: ([a-zA-Z0-9_\-]+);  state: (\w+);.*\n/ =~ r
	  date = $1
	  author = $2
	  state = $3
	  r = $'
	  if /\Abranches:\s*(.*);\n/ =~ r
	    r = $'
	    branches = $1.split(/;\s*/)
	  else
	    branches = []
	  end
	  log = r
	  yield DeltaInfo.new(
	    Revision.new(revision),
	    date,
	    author,
	    state,
	    branches.collect! {|b| Revision.new(b)},
	    log)
	}
	yield nil
      end
    }
  end

  def parse_rcsfile_log(rcsfile)
    tmprlog = @tmpdir.genname
    command = ["rlog", rcsfile]
    p command if $debug.include?(:command)
    child = fork {
      STDOUT.reopen(open(tmprlog, "w"))
      exec(*command)
    }
    Process.waitpid(child, nil)
    raise RCSCommandFailure.new if $? != 0
    parse_log(tmprlog) {|obj| yield obj}
    File.unlink(tmprlog)
  end

  def make_prefixdir(filename)
    filename = filename.clone
    if filename.sub!(/\/[^\/]*\z/, '')
      mkdir_recursive(filename)
    end
  end

  def mkdir_recursive(filename)
    return if FileTest.directory?(filename)
    begin
      Dir.mkdir(filename)
    rescue Errno::ENOENT
      mkdir_recursive(filename.sub(/\/[^\/]*\z/, ''))
      retry
    end
  end

  def find_rcs_file(relpath, working_file)
    local_rcsfile = @mirrordir + relpath + '/' + working_file + ',v'
    begin
      File.stat(local_rcsfile)
    rescue Errno::ENOENT
      local_rcsfile = @mirrordir + relpath + '/Attic/' + working_file + ',v'
      begin
	File.stat(local_rcsfile)
      rescue Errno::ENOENT
	local_rcsfile = nil
      end
    end
    return local_rcsfile
  end

  def master_lock(dir)
    mkdir_recursive(dir)
    n = 0
    begin
      Dir.mkdir("#{dir}/#cvs.lock")
    rescue Errno::EEXIST
      STDERR.print "master lock failed: #{dir}/\#cvs.lock\n"
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    end
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << '#cvs.lock'
  end

  def master_unlock(dir)
    Dir.rmdir("#{dir}/#cvs.lock")
    @lock[dir].delete('#cvs.lock') { raise InvalidUnlock.new }
  end

  def create_read_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_read_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def read_lock(dir)
    locked = false
    rlocked = false
    begin
      disable_interrupt {
	master_lock(dir); locked = true
	create_read_lock_file(dir); rlocked = true
	master_unlock(dir); locked = false
      }
      yield
    ensure
      delete_read_lock_file(dir) if rlocked
    end
  end

  def read_unlock(dir)
    rlockd = true
    begin
      delete_read_lock_file(dir); rlocked = false
      yield
    ensure
      disable_interrupt {
	master_lock(dir)
	create_read_lock_file(dir)
	master_unlock(dir)
      } unless rlocked
    end
  end

  def create_write_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_write_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def write_lock(dir)
    n = 0
    locked = false
    wlocked = false
    begin
      master_lock(dir); locked = true
      Dir.foreach(dir) {|f|
	next if @lock[dir].include?(f)
	if /\A\#cvs\.rfl/ =~ f
	  STDERR.print "read lock found: #{dir}/#{f}\n"
	  raise RetryLock.new
	end
      }
      create_write_lock_file(dir); wlocked = true
      yield
    rescue RetryLock
      master_unlock(dir); locked = false
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    ensure
      delete_write_lock_file(dir) if wlocked
      master_unlock(dir) if locked
    end
  end

  def disable_interrupt
    trap('INT', 'IGNORE')
    trap('TERM', 'IGNORE')
    if iterator?
      yield
      enable_interrupt
    end
  end

  def enable_interrupt
    trap('INT', 'DEFAULT')
    trap('TERM', 'DEFAULT')
  end

  def create_empty_file(filename)
    open(filename, "w") {}
  end

  def update(since=nil)
    queue = [""]
    while !queue.empty?
      relpath = queue.shift
      mod = @module + relpath
      @work.setup_workdir(mod)
      @work.getsubdirs.each {|subdir| queue << "#{relpath}/#{subdir}"}
      update_directory(relpath, since)
    end
  end

  def rcs_lock(rcsfile, lock_rev)
    command = ["rcs", "-q", "-l#{lock_rev}", rcsfile]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new if $? != 0
  end

  def checkin(rcsfile, rcsinfo, delta, tmpwork)
    tmpci = @tmpdir.alloc(rcsinfo.working_file)
    if FileTest.exist?(tmpwork)
      system "/bin/cp", tmpwork, tmpci
    else
      create_empty_file tmpci
    end
    make_prefixdir(rcsfile)
    command = ["ci",
      "-q#{delta.revision}",
      "-f",
      "-d#{delta.date}",
      "-m" + (/\A\s*\z/ =~ delta.log ? '*** empty log message ***' : delta.log),
      "-t-#{rcsinfo.description}",
      "-s#{delta.state}",
      "-w#{delta.author}",
      rcsfile,
      tmpci]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new if $? != 0
    @tmpdir.free(tmpci)
  end

  def update_directory(relpath, since)
    rcsinfo = nil
    deltas = nil
    parse_log(@work.getlogs(since)) {|obj|
      case obj
      when RCSInfo
	rcsinfo = obj
	deltas = []
      when DeltaInfo
	deltas << obj
      when NilClass
        update_file(relpath, rcsinfo, deltas)
      else
	raise Error.new
      end
    }
  end

  def update_rcs_attributes(relpath, rcsfile, rcsinfo, local_rcsinfo)
    args = []
    if rcsinfo.default_branch != local_rcsinfo.default_branch
      args << "-b#{rcsinfo.default_branch}"
    end
    if rcsinfo.keyword_substitution != local_rcsinfo.keyword_substitution
      args << "-k#{rcsinfo.keyword_substitution}"
    end
    rcsinfo.tags.reverse_each{|sym, rev|
      if pair = local_rcsinfo.tags.assoc(sym)
	args << "-N#{sym}:#{rev}" if pair[1] != rev
      else
	args << "-n#{sym}:#{rev}"
      end
    }
    unless args.empty?
      args << rcsfile
      command = ["rcs", "-q"] + args
      p command if $debug.include?(:command)
      disable_interrupt {
	write_lock(@mirrordir + relpath) {
	  system *command
	  raise RCSCommandFailure.new if $? != 0
	}
      }
    end
  end

  def update_file(relpath, rcsinfo, deltas)
    deltas = deltas.sort {|a, b| a.revision <=> b.revision}

    tmpwork = nil
    local_rcsinfo = nil
    deltas_to_checkin = []
    lock_to_checkin = {}
    read_lock(@mirrordir + relpath) {
      local_revisions = []
      if local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	local_revisions = []
	self.parse_rcsfile_log(local_rcsfile) {|obj|
	  case obj
	  when RCSInfo
	    local_rcsinfo = obj
	  when DeltaInfo
	    local_revisions << obj.revision
	  end
	}
      end
      deltas.each {|delta|
	delta.revision.checkinable?(local_revisions) {|lock_rev|
	  lock_to_checkin[delta] = lock_rev
	  deltas_to_checkin << delta
	  local_revisions << delta.revision
	}
      }
      if !deltas_to_checkin.empty?
	read_unlock(@mirrordir + relpath) {
	  deltas_to_checkin.each {|delta|
	    tmpwork = update_delta(relpath, rcsinfo, delta, lock_to_checkin[delta]) || tmpwork
	  }
	}
	if local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	  parse_rcsfile_log(local_rcsfile) {|obj|
	    local_rcsinfo = obj if obj.kind_of?(RCSInfo)
	  }
	end
      end

      if local_rcsfile
	update_rcs_attributes(relpath, local_rcsfile, rcsinfo, local_rcsinfo)
      end
    }

    begin
      File.unlink(tmpwork)
    rescue Errno::ENOENT
    end if tmpwork
  end

  def update_delta(relpath, rcsinfo, delta, lock)
    tmpwork = nil
    target = nil
    if delta.state == 'dead'
      # xxx: /dev/null is not correct.  it should point to the previous revision checkouted from local rcsfile.
      target = '/dev/null'
    else
      target = tmpwork = @work.getrevision(delta.revision, rcsinfo.working_file)
    end

    disable_interrupt {
      write_lock(@mirrordir + relpath) {
	local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	unless local_rcsfile
	  if delta.state == 'dead'
	    local_rcsfile = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	  else
	    local_rcsfile = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	  end
	end

	rcs_lock(local_rcsfile, lock) if lock && FileTest.exist?(local_rcsfile)
	checkin(local_rcsfile, rcsinfo, delta, target)

	if delta.revision.trunk?
	  if delta.state == 'dead'
	    local_rcsfile_new = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	  else
	    local_rcsfile_new = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	  end
	  if local_rcsfile != local_rcsfile_new
	    make_prefixdir(local_rcsfile_new)
	    print "rename #{local_rcsfile} -> #{local_rcsfile_new}\n" if $debug.include?(:attic)
	    File.rename(local_rcsfile, local_rcsfile_new)
	  end
	end
      }
    }
    return tmpwork
  end

end

$debug = []
$debug = [:command, :attic]

c = CVSMirror.new(ARGV[0], ARGV[1], ARGV[2])
c.update
c.cleanup
