#!/usr/local/bin/ruby

# cvssuck - cvs repository retrieving tool via cvs client/server protocol

# author:
#  Tanaka Akira <akr@m17n.org>

require "socket" # to use gethostname

class CouldNotLock<Exception
end

class RetryLock<Exception
end

class InvalidUnlock<Exception
end

class CVSCommandFailure<Exception
end

class CVSWork
  def initialize(cvsroot)
    @tmpdir = "/tmp/cvssuck-tmp-#{$$}"
    @tmpcount = 0
    @workdir = "#{@tmpdir}/w"
    Dir.mkdir(@tmpdir, 0700)
    Dir.mkdir("#{@workdir}")
    Dir.mkdir("#{@workdir}/CVS")
    open("#{@workdir}/CVS/Root", "w") {|f| f.print(cvsroot, "\n")}
  end

  def tmpfilename(filename=nil)
    @tmpcount += 1
    if filename
      Dir.mkdir("#{@tmpdir}/t#{@tmpcount}")
      return "#{@tmpdir}/t#{@tmpcount}/#{filename}"
    else
      return "#{@tmpdir}/t#{@tmpcount}"
    end
  end

  def setup_workdir(repository)
    open("#{@workdir}/CVS/Repository", "w") {|f| f.print(repository, "\n")}
    open("#{@workdir}/CVS/Entries", "w") {|f| f.print("D\n")}
    Dir.foreach(@workdir) {|f|
      next if /\A(\.\.|\.|CVS)\z/ =~ f
      File.unlink("#{@workdir}/#{f}")
    }
  end

  def run_cvs_internal(childproc, *args)
    command = ["cvs", "-f"] + args
    #p command
    child = fork {
      childproc.call if childproc
      Dir.chdir(@workdir)
      exec(*command)
    }
    result = yield if iterator?
    Process.waitpid(child, nil)
    raise CVSCommandFailure.new if $? != 0
    return result
  end

  def run_cvs_stdout(*args)
    result = nil
    r, w = IO.pipe
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(w)
	#STDERR.reopen(open("/dev/null"))
	r.close
	w.close
      }, *args) {
      w.close
      result = yield(r)
      r.close
    }
    return result
  end

  def run_cvs_stderr(*args)
    result = nil
    r, w = IO.pipe
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(open("/dev/null"))
	STDERR.reopen(w)
	r.close
	w.close
      }, *args) {
      w.close
      result = yield(r)
      r.close
    }
    return result
  end

  def run_cvs_stdout_file(*args)
    tmpfile = self.tmpfilename
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(open(tmpfile, "w"))
	#STDERR.reopen(open("/dev/null"))
      }, *args)
    return tmpfile
  end

  def run_cvs(*args)
    self.run_cvs_internal(Proc.new {
	#STDOUT.reopen(open("/dev/null"))
	STDERR.reopen(open("/dev/null"))
      }, *args)
  end

  def getlogs(since=nil)
    args = ["-Q", "log"]
    args << "-d#{since}<" if since
    tmpfile = self.run_cvs_stdout_file(*args)
    return tmpfile
  end

  def getsubdirs
    result = []
    self.run_cvs_stderr("-Q", "update", "-r00", "-d", "-p", ".") {|f|
      f.each_line {|l| result << $1 if /cvs server: New directory `(.*)' -- ignored\n/ =~ l && /\A(?:\.|\.\.)\z/ != $1}
    }
    return result
  end

  def getrevision(rev, filename)
    # -kb is not suitable because it prevents delta transmission.
    # -Q doesn't prevent the message `cvs server: warning: a is not (any longer) pertinent'.
    self.run_cvs("-Q", "update", "-ko", "-r#{rev}", filename)
    return "#{@workdir}/#{filename}"
  end

  def cleanup
    system("/bin/rm -rf #{@tmpdir}")
  end
end

DeltaInfo = Struct.new("DeltaInfo",
  :revision, :date, :author, :state, :branches, :log)

RCSInfo = Struct.new("RCSInfo",
  :rcs_file, :working_file, :head, :default_branch, :tags, :keyword_substitution, :description)

class CVSMirror
  def initialize(mirrordir, cvsroot, mod)
    @mirrordir = mirrordir
    @cvsroot = cvsroot
    @module = mod
    @work = CVSWork.new(@cvsroot)
    @lock = {}
  end

  def cleanup
    @work.cleanup
  end

  class LogFormatError < Exception
  end

  def parse_log(logfile)
    open(logfile) {|f|
      file_delimiter = "\n=============================================================================\n"
      delta_delimiter = /\n----------------------------\n/
      while l = f.gets(file_delimiter)
	if file_delimiter.length <= l.length && file_delimiter == l[l.length - file_delimiter.length, file_delimiter.length]
	  l[l.length - file_delimiter.length, file_delimiter.length] = "\n"
	end
        header, *deltas = l.split(delta_delimiter)
	header << "\n" if header !~ /\n\z/
	raise LogFormatError.new unless /^RCS file: (.*)\n/ =~ header; rcs_file = $1
	raise LogFormatError.new unless /^Working file: (.*)\n/ =~ header; working_file = $1
	raise LogFormatError.new if /\/|\A(?:\.\.|\.)\z/ =~ working_file 
	raise LogFormatError.new unless /^head: (.*)\n/ =~ header; head = $1
	/^branch: (.*)\n/ =~ header; default_branch = $1
	raise LogFormatError.new unless /^symbolic names:\n((?:\t.*\n)*)/ =~ header; symbolic_names = $1
	tags = symbolic_names.split(/\n/).collect! {|l| l.split(/[\s:]+/)[1,2]}
	raise LogFormatError.new unless /^keyword substitution: (.*)\n/ =~ header; keyword_substitution = $1
	raise LogFormatError.new unless /^description:\n/ =~ header; description = $'
	yield RCSInfo.new(rcs_file, working_file, head, default_branch, tags, keyword_substitution, description)
	deltas.each {|r|
	  raise LogFormatError.new unless /\Arevision ([.\d]*).*\n/ =~ r
	  revision = $1
	  r = $'
	  raise LogFormatError.new unless /\Adate: (\d+\/\d+\/\d+ \d+:\d+:\d+);  author: ([a-zA-Z0-9_\-]+);  state: (\w+);.*\n/ =~ r
	  date = $1
	  author = $2
	  state = $3
	  r = $'
	  if /\Abranches:\s*(.*);\n/ =~ r
	    r = $'
	    branches = $1.split(/;\s*/)
	  else
	    branches = []
	  end
	  log = r
	  yield DeltaInfo.new(revision, date, author, state, branches, log)
	}
	yield nil
      end
    }
  end

  def parse_rcsfile_log(rcsfile)
    tmprlog = @work.tmpfilename
    command = "rlog #{rcsfile} > #{tmprlog}"
    #p command
    system(command)
    parse_log(tmprlog) {|obj| yield obj}
    File.unlink(tmprlog)
  end

  def collect_revisions(rcsfile)
    revisions = []
    self.parse_rcsfile_log(rcsfile) {|obj| revisions << obj.revision if obj.kind_of?(DeltaInfo)}
    return revisions
  end

  def make_prefixdir(filename)
    filename = filename.clone
    if filename.sub!(/\/[^\/]*\z/, '')
      mkdir_recursive(filename)
    end
  end

  def mkdir_recursive(filename)
    return if FileTest.directory?(filename)
    begin
      Dir.mkdir(filename)
    rescue Errno::ENOENT
      mkdir_recursive(filename.sub(/\/[^\/]*\z/, ''))
      retry
    end
  end

  def find_rcs_file(relpath, working_file)
    local_rcsfile = @mirrordir + relpath + '/' + working_file + ',v'
    begin
      File.stat(local_rcsfile)
    rescue Errno::ENOENT
      local_rcsfile = @mirrordir + relpath + '/Attic/' + working_file + ',v'
      begin
	File.stat(local_rcsfile)
      rescue Errno::ENOENT
	local_rcsfile = nil
      end
    end
    return local_rcsfile
  end

  def master_lock(dir)
    mkdir_recursive(dir)
    n = 0
    begin
      Dir.mkdir("#{dir}/#cvs.lock")
    rescue Errno::EEXIST
      STDERR.print "master lock failed: #{dir}/\#cvs.lock\n"
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    end
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << '#cvs.lock'
  end

  def master_unlock(dir)
    Dir.rmdir("#{dir}/#cvs.lock")
    @lock[dir].delete('#cvs.lock') { raise InvalidUnlock.new }
  end

  def create_read_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_read_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def read_lock(dir)
    locked = false
    rlocked = false
    begin
      disable_interrupt {
	master_lock(dir); locked = true
	create_read_lock_file(dir); rlocked = true
	master_unlock(dir); locked = false
      }
      yield
    ensure
      delete_read_lock_file(dir) if rlocked
    end
  end

  def create_write_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_write_lock_file(dir, info=".#{Socket.gethostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def write_lock(dir)
    n = 0
    locked = false
    wlocked = false
    begin
      master_lock(dir); locked = true
      Dir.foreach(dir) {|f|
	next if @lock[dir].include?(f)
	if /\A\#cvs\.rfl/ =~ f
	  STDERR.print "read lock found: #{dir}/#{f}\n"
	  raise RetryLock.new
	end
      }
      create_write_lock_file(dir); wlocked = true
      yield
    rescue RetryLock
      master_unlock(dir); locked = false
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    ensure
      delete_write_lock_file(dir) if wlocked
      master_unlock(dir) if locked
    end
  end

  def disable_interrupt
    trap('INT', 'IGNORE')
    trap('TERM', 'IGNORE')
    if iterator?
      yield
      enable_interrupt
    end
  end

  def enable_interrupt
    trap('INT', 'DEFAULT')
    trap('TERM', 'DEFAULT')
  end

  def create_empty_file(filename)
    open(filename, "w") {}
  end

  def update(since=nil)
    queue = [""]
    while !queue.empty?
      relpath = queue.shift
      mod = @module + relpath
      @work.setup_workdir(mod)
      @work.getsubdirs.each {|subdir| queue << "#{relpath}/#{subdir}"}
      update_directory(relpath, since)
    end
  end

  def checkinable?(local_rcsfile, rev)
    lock_rev = nil
    if local_rcsfile
      @old_local_revisions = local_revisions = collect_revisions(local_rcsfile)
      if /\A(\d+)\.(\d+)\z/ =~ rev
	reva = [$1.to_i, $2.to_i]
	# it's on a maintrunk.
	high_enough = true
	local_revisions.each {|lrev|
	  if /\A(\d+)\.(\d+)\z/ =~ lrev
	    lreva = [$1.to_i, $2.to_i]
	    if (reva <=> lreva) <= 0
	      high_enough = false
	      break
	    end
	  end
	}
	return unless high_enough
	lock_rev = ''
      else
	# it's on a branch.
	#p rev
	branch = rev.sub(/\.\d+\z/, '')
	branchpoint = branch.sub(/\.\d+\z/, '')
	branch_regex = /\A#{Regexp.quote(branch + '.')}(\d+)\z/
	branch_rev = rev.sub(/\A.*\./, '').to_i
	branch_exist = false
	branchpoint_exist = false
	high_enough = true
	local_revisions.each {|lrev|
	  branchpoint_exist = true if lrev == branchpoint
	  if branch_regex =~ lrev
	    branch_exist = true
	    if branch_rev <= $1.to_i
	      high_enough = false
	      break
	    end
	  end
	}
	return unless high_enough && branchpoint_exist
	if branch_exist
	  lock_rev = branch
	else
	  lock_rev = nil
	end
      end
    else
      if /\A\d+\.\d+\z/ !~ rev 
	# the revision is not on a maintrunk.
	# non-maintrunk revision needs a branchpoint to check in.
	return
      end
    end
    yield lock_rev
  end

  def rcs_lock(rcsfile, lock_rev)
    command = ["rcs", "-q", "-l#{lock_rev}", rcsfile]
    #p command
    system *command
  end

  def checkin(rcsfile, rcsinfo, delta, tmpwork)
    tmpcidir = @work.tmpfilename
    Dir.mkdir(tmpcidir)
    tmpci = "#{tmpcidir}/#{rcsinfo.working_file}"
    if FileTest.exist?(tmpwork)
      system "/bin/cp", tmpwork, tmpci
    else
      create_empty_file tmpci
    end
    make_prefixdir(rcsfile)
    command = ["ci",
      "-q#{delta.revision}",
      "-f",
      "-d#{delta.date}",
      "-m" + (/\A\s*\z/ =~ delta.log ? '*** empty log message ***' : delta.log),
      "-t-#{rcsinfo.description}",
      "-s#{delta.state}",
      "-w#{delta.author}",
      rcsfile,
      tmpci]
    #p command
    system *command
    Dir.rmdir(tmpcidir)
  end

  def update_directory(relpath, since)
    rcsinfo = nil
    deltas = nil
    parse_log(@work.getlogs(since)) {|obj|
      case obj
      when RCSInfo
	rcsinfo = obj
	deltas = []
      when DeltaInfo
	deltas << obj
      when NilClass
        update_file(relpath, rcsinfo, deltas)
      else
	raise Error.new
      end
    }
  end

  def update_file(relpath, rcsinfo, deltas)
    deltas_hash = {}
    deltas.each {|delta|
      deltas_hash[delta.revision.split(/\./).collect! {|n| n.to_i}] = delta
    }
    deltas = deltas_hash.keys.sort.collect! {|key| deltas_hash[key]}
      
    @old_local_revisions = nil
    tmpwork = nil
    deltas.each {|delta|
      rev = delta.revision
      next if @old_local_revisions && @old_local_revisions.include?(rev)
      read_lock(@mirrordir + relpath) {
	local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	checkinable?(local_rcsfile, rev) {|lock_rev|
	  unless local_rcsfile
	    if delta.state == 'dead'
	      local_rcsfile = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	    else
	      local_rcsfile = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	    end
	  end
	  tmpwork = @work.getrevision(rev, rcsinfo.working_file)

	  #print "#{tmpwork} #{rev}\n"

	  disable_interrupt {
	    write_lock(@mirrordir + relpath) {
	      rcs_lock(local_rcsfile, lock_rev) if lock_rev
	      checkin(local_rcsfile, rcsinfo, delta, tmpwork)
	    }
	  }
	}
      }
    }

    read_lock(@mirrordir + relpath) {
      if local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	local_rcsinfo = nil
	head_delta = nil
	in_attic = nil
	parse_rcsfile_log(local_rcsfile) {|obj|
	  case obj
	  when RCSInfo
	    local_rcsinfo = obj
	  when DeltaInfo
	    head_delta = obj if obj.revision == rcsinfo.head
	  when NilClass
	    in_attic = head_delta.state == 'dead'
	  else
	    raise Error.new
	  end
	}

	if in_attic
	  local_rcsfile_new = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	else
	  local_rcsfile_new = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	end
	if local_rcsfile != local_rcsfile_new
	  make_prefixdir(local_rcsfile_new)
	  #print "#{local_rcsfile} -> #{local_rcsfile_new}\n"
	  File.rename(local_rcsfile, local_rcsfile_new)
	  local_rcsfile = local_rcsfile_new
	end

	#update_rcs_attributes(local_rcsfile, rcsinfo, local_rcsinfo)
	args = []
	if rcsinfo.default_branch != local_rcsinfo.default_branch
	  args << "-b#{rcsinfo.default_branch}"
	end
	if rcsinfo.keyword_substitution != local_rcsinfo.keyword_substitution
	  args << "-k#{rcsinfo.keyword_substitution}"
	end
	rcsinfo.tags.reverse_each{|sym, rev|
	  if pair = local_rcsinfo.tags.assoc(sym)
	    if pair[1] != rev
	      args << "-N#{sym}:#{rev}"
	    end
	  else
	    args << "-n#{sym}:#{rev}"
	  end
	}
	unless args.empty?
	  args << local_rcsfile
	  command = ["rcs", "-q"] + args
	  #p command
	  disable_interrupt {
	    write_lock(@mirrordir + relpath) {
	      system *command
	    }
	  }
	end

      end
    }

    begin
      File.unlink(tmpwork)
    rescue Errno::ENOENT
    end if tmpwork
  end

end

c = CVSMirror.new(ARGV[0], ARGV[1], ARGV[2])
c.update
c.cleanup
