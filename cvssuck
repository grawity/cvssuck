#!/usr/local/bin/ruby

# CVSsuck - cvs repository retrieving tool via cvs client/server protocol

# usage:
#
# % cvssuck [-s] [-t] [-o output-directory] cvsroot module
# 
# -s : skeleton mode
# -t : translation mode

# example:
#
# % cvssuck :pserver:anonymous@cvs.m17n.org:/cvs/cvs cvssuck

# author:
#  Tanaka Akira <akr@m17n.org>

require 'parsearg'
require 'socket' # to use gethostname

class Set<Hash
  def <<(obj)
    self[obj] = true
  end
end

class LogFormatError<Exception
end

class CouldNotLock<Exception
end

class RetryLock<Exception
end

class InvalidUnlock<Exception
end

class CVSCommandFailure<Exception
  def initialize(status)
    super("status: #{status}")
  end
end

class RCSCommandFailure<Exception
  def initialize(status)
    super("status: #{status}")
  end
end

class Tempdir
  def initialize(keyword="cvssuck")
    @count = 0
    @top = "/tmp/#{keyword}-#{$$}"
    Dir.mkdir(@top, 0755)
    @dirs = [@top]
    @allocated = {}
  end

  def genname
    @count += 1 while @allocated.include?(name = "#{@top}/t#{@count}")
    @allocated[name] = true
    return name
  end

  def alloc(basename=nil)
    if basename
      @dirs.each {|d|
	unless @allocated.include?(name = "#{d}/#{basename}")
	  @allocated[name] = true
	  return name
	end
      }
      d = genname
      Dir.mkdir(d, 0755)
      @dirs << d
      name = "#{d}/#{basename}"
      @allocated[name] = true
      return name
    else
      return genname
    end
  end

  def free(name)
    raise Error.new unless @allocated.delete(name)
    if FileTest.exist?(name)
      system "/bin/rm", "-rf", name
    end
  end

  def cleanup
    system "/bin/rm", "-rf", @top
  end
end

class Revision
  def initialize(str)
    raise Error.new unless /\A\d+(?:\.\d+)*\z/ =~ str
    @str = str
    @arr = str.split(/\./); @arr.collect! {|n| n.to_i}
  end

  def to_s
    return @str
  end

  attr_reader :arr

  def <=>(other)
    result = @arr.length <=> other.arr.length
    result = @arr <=> other.arr if result == 0
    return result
  end

  def ==(other)
    return false unless other.kind_of?(Revision)
    return (self <=> other) == 0
  end

  def <(other)
    return (self <=> other) < 0
  end

  def >(other)
    return (self <=> other) > 0
  end

  def <=(other)
    return (self <=> other) <= 0
  end

  def >=(other)
    return (self <=> other) >= 0
  end

  def hash
    return @arr.hash
  end

  def eql?(other)
    return self == other
  end

  def trunk?
    return @arr.length == 2
  end

  def branch?
    return (@arr.length & 1) == 1
  end

  def magic_branch?
    return (@arr.length & 1) == 0 && 4 <= @arr.length && @arr[-2] == 0
  end

  def on?(br)
    return br.branch? && @arr.length == br.arr.length + 1 && @arr[0, @arr.length - 1] == br.arr
  end

  def same_branch?(other)
    return (@arr.length == other.arr.length) && (trunk? || (@arr[0, @arr.length - 1] == other.arr[0, @arr.length - 1]))
  end

  def branch
    raise Error.new if branch?
    return Revision.new(@str.sub(/\.\d+\z/, ''))
  end

  def branch_point
    raise Error.new if branch?
    return Revision.new(@str.sub(/\.\d+\.\d+\z/, ''))
  end

end

class RevisionSet
  def initialize(revs=[])
    @revs = {}
    @head = {}
    revs.each {|r| self << r}
  end

  def <<(rev)
    @revs[rev] = true
    b = rev.trunk? ? nil : rev.branch
    @head[b] = rev if !@head.key?(b) || @head[b] < rev
  end

  def include?(rev)
    return @revs.include?(rev)
  end

  def checkinable?(rev)
    return if rev.branch?
    if rev.trunk?
      b = nil
      if @head.key?(b)
        yield @head[b] if @head[b] < rev
      else
        yield nil
      end
    else
      b = rev.branch
      if @head.key?(b)
        yield @head[b] if @head[b] < rev
      else
        yield nil if @revs.include?(rev.branch_point)
      end
    end
  end
end

DeltaInfo = Struct.new("DeltaInfo",
  :revision, :date, :author, :state, :branches, :log)

RCSInfo = Struct.new("RCSInfo",
  :rcs_file, :working_file, :head, :default_branch, :tags, :keyword_substitution, :description)

class RCSLog
  def RCSLog.parse_log(logfile)
    open(logfile) {|f|
      file_delimiter = "\n=============================================================================\n"
      delta_delimiter = /\n----------------------------\n/
      while l = f.gets(file_delimiter)
	if file_delimiter.length <= l.length && file_delimiter == l[l.length - file_delimiter.length, file_delimiter.length]
	  l[l.length - file_delimiter.length, file_delimiter.length] = "\n"
	end
        header, *deltas = l.split(delta_delimiter)
	header << "\n" if header !~ /\n\z/
	raise LogFormatError.new unless /^RCS file: (.*)\n/ =~ header; rcs_file = $1
	raise LogFormatError.new unless /^Working file: (.*)\n/ =~ header; working_file = $1
	raise LogFormatError.new if /\/|\A(?:\.\.|\.)\z/ =~ working_file 
	raise LogFormatError.new unless /^head: (.*)\n/ =~ header; head = $1
	/^branch: (.*)\n/ =~ header; default_branch = $1
	raise LogFormatError.new unless /^symbolic names:\n((?:\t.*\n)*)/ =~ header; symbolic_names = $1
	tags = symbolic_names.split(/\n/).collect! {|l| l.split(/[\s:]+/)[1,2]}
	raise LogFormatError.new unless /^keyword substitution: (.*)\n/ =~ header; keyword_substitution = $1
	if /^description:\n/ =~ header; description = $'; else description = nil; end
	yield RCSInfo.new(
	  rcs_file,
	  working_file,
	  Revision.new(head),
	  default_branch ? Revision.new(default_branch) : nil,
	  tags.collect! {|sym, rev| [sym, Revision.new(rev)]},
	  keyword_substitution,
	  description)
	deltas.each {|r|
	  raise LogFormatError.new unless /\Arevision ([.\d]*).*\n/ =~ r
	  revision = $1
	  r = $'
	  raise LogFormatError.new unless /\Adate: (\d+\/\d+\/\d+ \d+:\d+:\d+);  author: ([a-zA-Z0-9_\-]+);  state: (\w+);.*\n/ =~ r
	  date = $1
	  author = $2
	  state = $3
	  r = $'
	  if /\Abranches:\s*(.*);\n/ =~ r
	    r = $'
	    branches = $1.split(/;\s*/)
	  else
	    branches = []
	  end
	  log = r
	  yield DeltaInfo.new(
	    Revision.new(revision),
	    date,
	    author,
	    state,
	    branches.collect! {|b| Revision.new(b)},
	    log)
	}
	yield nil
      end
    }
  end
end

class CVSWork
  def initialize(cvsroot, tmpdir)
    @tmpdir = tmpdir
    @workdir = @tmpdir.genname
    Dir.mkdir(@workdir)
    Dir.mkdir("#{@workdir}/CVS")
    open("#{@workdir}/CVS/Root", "w") {|f| f.print(cvsroot, "\n")}
    @cache_filename = nil
    @cache_path = nil
  end

  def setup_workdir(repository)
    discard_cache
    open("#{@workdir}/CVS/Repository", "w") {|f| f.print(repository, "\n")}
    open("#{@workdir}/CVS/Entries", "w") {|f| f.print("D\n")}
    Dir.foreach(@workdir) {|f|
      next if /\A(\.\.|\.|CVS)\z/ =~ f
      File.unlink("#{@workdir}/#{f}")
    }
  end

  def run_cvs_internal(childproc, *args)
    #command = ["cvs", "-f", "-z3"] + args
    command = ["cvs", "-f"] + args
    p command if $debug.include?(:command)
    child = fork {
      childproc.call if childproc
      Dir.chdir(@workdir)
      exec(*command)
    }
    result = yield if iterator?
    Process.waitpid(child, nil)
    raise CVSCommandFailure.new($?) if $? != 0
    return result
  end

  def run_cvs_stderr(*args)
    result = nil
    r, w = IO.pipe
    self.run_cvs_internal(Proc.new {
	STDOUT.reopen(open("/dev/null"))
	STDERR.reopen(w)
	r.close
	w.close
      }, *args) {
      w.close
      result = yield(r)
      r.close
    }
    return result
  end

  def run_cvs_stdout_file(*args)
    tmpfile = @tmpdir.genname
    self.run_cvs_internal(Proc.new {
	ENV['CVS_CLIENT_LOG'] = tmpfile
	STDOUT.reopen(open(tmpfile, "w"))
      }, *args)
    return tmpfile
  end

  def run_cvs(*args)
    self.run_cvs_internal(nil, *args)
  end

  def getlogs(since=nil)
    args = ["-q", "log"]
    args << "-d#{since}<" if since
    p "getlogs begin" if $debug.include?(:hotspot)
    tmpfile = self.run_cvs_stdout_file(*args)
    p "getlogs end" if $debug.include?(:hotspot)
    return tmpfile
  end

  def parselogs(since=nil)
    tmpfile = nil
    begin
      tmpfile = self.getlogs(since)
    rescue CVSCommandFailure
      args = ["-q", "log", "-h"]
      tmpfile = self.run_cvs_stdout_file(*args)
      RCSLog.parse_log(tmpfile) {|obj|
	if obj.kind_of?(RCSInfo)
	  rcsinfo = obj
	  args = ["-q", "log", rcsinfo.working_file]
	  tmpfile2 = self.run_cvs_stdout_file(*args)
	  RCSLog.parse_log(tmpfile2) {|obj| yield obj}
	  File.unlink tmpfile2
	end
      }
      return
    end

    RCSLog.parse_log(tmpfile) {|obj| yield obj}
  end

  def getsubdirs
    result = []
    self.run_cvs_stderr("-q", "update", "-r00", "-d", "-p", ".") {|f|
      f.each_line {|l| result << $1 if /cvs server: New directory `(.*)' -- ignored\n/ =~ l && /\A(?:\.|\.\.)\z/ != $1}
    }
    return result
  end

  def getrevision(rev, filename)
    discard_cache if @cache_filename != filename
    # -kb is not suitable because it prevents delta transmission.
    self.run_cvs("-Q", "update", "-ko", "-r#{rev}", filename)
    @cache_filename = filename
    @cache_path = "#{@workdir}/#{filename}"
    return @cache_path
  end

  def discard_cache
    if @cache_filename
      File.unlink(@cache_path)
      @cache_filename = nil
      @cache_path = nil
    end
  end

  def cleanup
    discard_cache
  end
end

class CVSMirror
  def initialize(mirrordir, cvsroot, mod)
    @tmpdir = Tempdir.new
    @mirrordir = mirrordir
    @cvsroot = cvsroot
    @module = mod
    @work = CVSWork.new(@cvsroot, @tmpdir)
    @lock = {}
    @hostname = Socket.gethostname
  end

  def cleanup
    @work.cleanup
    @tmpdir.cleanup
  end

  def parse_rcsfile_log(rcsfile)
    tmprlog = @tmpdir.genname
    command = ["rlog", rcsfile]
    p command if $debug.include?(:command)
    child = fork {
      STDOUT.reopen(open(tmprlog, "w"))
      exec(*command)
    }
    Process.waitpid(child, nil)
    raise RCSCommandFailure.new($?) if $? != 0
    RCSLog.parse_log(tmprlog) {|obj| yield obj}
    File.unlink(tmprlog)
  end

  def make_prefixdir(filename)
    filename = filename.clone
    if filename.sub!(/\/[^\/]*\z/, '')
      mkdir_recursive(filename)
    end
  end

  def mkdir_recursive(filename)
    return if FileTest.directory?(filename)
    begin
      Dir.mkdir(filename)
    rescue Errno::ENOENT
      mkdir_recursive(filename.sub(/\/[^\/]*\z/, ''))
      retry
    end
  end

  def find_rcs_file(relpath, working_file)
    local_rcsfile = @mirrordir + relpath + '/' + working_file + ',v'
    begin
      File.stat(local_rcsfile)
    rescue Errno::ENOENT
      local_rcsfile = @mirrordir + relpath + '/Attic/' + working_file + ',v'
      begin
	File.stat(local_rcsfile)
      rescue Errno::ENOENT
	local_rcsfile = nil
      end
    end
    return local_rcsfile
  end

  def master_lock(dir)
    mkdir_recursive(dir)
    n = 0
    begin
      Dir.mkdir("#{dir}/#cvs.lock")
    rescue Errno::EEXIST
      STDERR.print "master lock failed: #{dir}/\#cvs.lock\n"
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    end
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << '#cvs.lock'
  end

  def master_unlock(dir)
    Dir.rmdir("#{dir}/#cvs.lock")
    @lock[dir].delete('#cvs.lock') { raise InvalidUnlock.new }
  end

  def create_read_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_read_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.rfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def read_lock(dir)
    locked = false
    rlocked = false
    begin
      disable_interrupt {
	master_lock(dir); locked = true
	create_read_lock_file(dir); rlocked = true
	master_unlock(dir); locked = false
      }
      yield
    ensure
      delete_read_lock_file(dir) if rlocked
    end
  end

  def read_unlock(dir)
    rlockd = true
    begin
      delete_read_lock_file(dir); rlocked = false
      yield
    ensure
      disable_interrupt {
	master_lock(dir)
	create_read_lock_file(dir)
	master_unlock(dir)
      } unless rlocked
    end
  end

  def create_write_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir] = [] if @lock[dir] == nil
    @lock[dir] << f
    create_empty_file "#{dir}/#{f}"
  end

  def delete_write_lock_file(dir, info=".#{@hostname}.#{$$}")
    f = "\#cvs.wfl#{info}"
    @lock[dir].delete(f) { raise InvalidUnlock.new }
    File.unlink "#{dir}/#{f}"
  end

  def write_lock(dir)
    n = 0
    locked = false
    wlocked = false
    begin
      master_lock(dir); locked = true
      Dir.foreach(dir) {|f|
	next if @lock[dir].include?(f)
	if /\A\#cvs\.rfl/ =~ f
	  STDERR.print "read lock found: #{dir}/#{f}\n"
	  raise RetryLock.new
	end
      }
      create_write_lock_file(dir); wlocked = true
      yield
    rescue RetryLock
      master_unlock(dir); locked = false
      raise CouldNotLock.new if (n += 1) == 10
      secs = 30 + rand(30)
      STDERR.print "waiting #{secs} seconds... (#{n} times tried.)\n"
      sleep secs
      retry
    ensure
      delete_write_lock_file(dir) if wlocked
      master_unlock(dir) if locked
    end
  end

  def disable_interrupt
    trap('INT', 'IGNORE')
    trap('TERM', 'IGNORE')
    if iterator?
      yield
      enable_interrupt
    end
  end

  def enable_interrupt
    trap('INT', 'DEFAULT')
    trap('TERM', 'DEFAULT')
  end

  def create_empty_file(filename)
    open(filename, "w") {}
  end

  def update(filter=Filter::All.new, since=nil)
    queue = [""]
    while !queue.empty?
      relpath = queue.shift
      mod = @module + relpath
      @work.setup_workdir(mod)
      @work.getsubdirs.each {|subdir| queue << "#{relpath}/#{subdir}"}
      update_directory(relpath, filter, since)
    end
  end

  def rcs_lock(rcsfile, lock_rev)
    command = ["rcs", "-q", "-l#{lock_rev}", rcsfile]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new($?) if $? != 0
  end

  def checkin(rcsfile, rcsinfo, delta, filename)
    tmpci = @tmpdir.alloc(rcsinfo.working_file)
    if FileTest.exist?(filename)
      system "/bin/cp", filename, tmpci
    else
      create_empty_file tmpci
    end
    make_prefixdir(rcsfile)
    command = ["ci",
      "-q#{delta.revision}",
      "-f",
      "-d#{delta.date}",
      "-m" + (/\A\s*\z/ =~ delta.log ? '*** empty log message ***' : delta.log),
      "-t-#{rcsinfo.description}",
      "-s#{delta.state}",
      "-w#{delta.author}",
      rcsfile,
      tmpci]
    p command if $debug.include?(:command)
    system *command
    raise RCSCommandFailure.new($?) if $? != 0
    @tmpdir.free(tmpci)
  end

  def update_directory(relpath, filter, since)
    rcsinfo = nil
    deltas = nil
    @work.parselogs(since) {|obj|
      case obj
      when RCSInfo
	rcsinfo = obj
	deltas = []
      when DeltaInfo
	deltas << obj
      when NilClass
        update_file(relpath, rcsinfo, deltas, filter)
      else
	raise Error.new
      end
    }
  end

  def update_rcs_attributes(relpath, rcsfile, rcsinfo, local_rcsinfo)
    args = []
    if rcsinfo.default_branch != local_rcsinfo.default_branch
      args << "-b#{rcsinfo.default_branch}"
    end
    if rcsinfo.keyword_substitution != local_rcsinfo.keyword_substitution
      args << "-k#{rcsinfo.keyword_substitution}"
    end
    rcsinfo.tags.reverse_each{|sym, rev|
      if pair = local_rcsinfo.tags.assoc(sym)
	args << "-N#{sym}:#{rev}" if pair[1] != rev
      else
	args << "-n#{sym}:#{rev}"
      end
    }
    unless args.empty?
      args << rcsfile
      command = ["rcs", "-q"] + args
      p command if $debug.include?(:command)
      disable_interrupt {
	write_lock(@mirrordir + relpath) {
	  system *command
	  raise RCSCommandFailure.new($?) if $? != 0
	}
      }
    end
  end

  def update_file(relpath, rcsinfo, deltas, filter)
    deltas = deltas.sort {|a, b| a.revision <=> b.revision}

    local_rcsinfo = nil
    deltas_to_checkin = []
    lock_to_checkin = {}
    read_lock(@mirrordir + relpath) {
      p "planning begin #{tbeg = Time.now}" if $debug.include?(:hotspot)
      local_revisions = RevisionSet.new
      if local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	self.parse_rcsfile_log(local_rcsfile) {|obj|
	  case obj
	  when RCSInfo
	    local_rcsinfo = obj
	  when DeltaInfo
	    local_revisions << obj.revision
	  end
	}
      end
      revs = Set.new
      filter.filter(rcsinfo, deltas).each{|r| revs << r}
      p "planning mid #{tmid = Time.now} #{tmid - tbeg}" if $debug.include?(:hotspot)
      deltas.each {|delta|
	if revs.include?(delta.revision)
	  local_revisions.checkinable?(delta.revision) {|lock_rev|
	    lock_to_checkin[delta] = lock_rev
	    deltas_to_checkin << delta
	    local_revisions << delta.revision
	  }
	end
      }
      p "planning end #{tend = Time.now} #{tend - tbeg}" if $debug.include?(:hotspot)
      if !deltas_to_checkin.empty?
	read_unlock(@mirrordir + relpath) {
	  deltas_to_checkin.each {|delta|
	    update_delta(relpath, rcsinfo, delta, lock_to_checkin[delta])
	  }
	}
	if local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	  parse_rcsfile_log(local_rcsfile) {|obj|
	    local_rcsinfo = obj if obj.kind_of?(RCSInfo)
	  }
	end
      end

      if local_rcsfile
	update_rcs_attributes(relpath, local_rcsfile, rcsinfo, local_rcsinfo)
      end
    }
  end

  def update_delta(relpath, rcsinfo, delta, lock)
    target = nil
    if delta.state == 'dead'
      # xxx: /dev/null is not correct.  it should point to the previous revision checkouted from local rcsfile.
      target = '/dev/null'
    else
      target = @work.getrevision(delta.revision, rcsinfo.working_file)
    end

    disable_interrupt {
      write_lock(@mirrordir + relpath) {
	local_rcsfile = find_rcs_file(relpath, rcsinfo.working_file)
	unless local_rcsfile
	  if delta.state == 'dead' || (delta.revision == rcsinfo.head && /\/Attic\/[^\/]+\z/ =~ rcsinfo.rcs_file)
	    local_rcsfile = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	  else
	    local_rcsfile = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	  end
	end

	rcs_lock(local_rcsfile, lock) if lock && FileTest.exist?(local_rcsfile)
	checkin(local_rcsfile, rcsinfo, delta, target)

	if delta.revision.trunk?
	  if delta.state == 'dead' || (delta.revision == rcsinfo.head && /\/Attic\/[^\/]+\z/ =~ rcsinfo.rcs_file)
	    local_rcsfile_new = @mirrordir + relpath + '/Attic/' + rcsinfo.working_file + ',v'
	  else
	    local_rcsfile_new = @mirrordir + relpath + '/' + rcsinfo.working_file + ',v'
	  end
	  if local_rcsfile != local_rcsfile_new
	    make_prefixdir(local_rcsfile_new)
	    print "rename #{local_rcsfile} -> #{local_rcsfile_new}\n" if $debug.include?(:attic)
	    File.rename(local_rcsfile, local_rcsfile_new)
	  end
	end
      }
    }
  end

end

module Filter
  class All
    def filter(rcsinfo, deltas)
      revs = deltas.clone
      revs.collect! {|d| d.revision}
      return revs
    end
  end

  class Skeleton
    def filter(rcsinfo, deltas)
      revs = deltas.clone
      revs.collect! {|d| d.revision}
      revs.sort!

      result = []
      r1 = nil
      revs.each {|r2|
	if r1 && !r1.same_branch?(r2)
	  result << r1
	  result << r2.branch_point unless r2.trunk?
	end
	r1 = r2
      }
      if 0 < revs.length
        result << revs[0]
        result << revs[-1]
      end
      if revs.include?(r = Revision.new("1.1"))
	# 1.1 is important because it is a branch point of vendor branches.
        result << r
      end
      rcsinfo.tags.each {|s, r|
        if r.magic_branch?
	  result << r.branch_point
	elsif !r.branch?
	  result << r
	end
      }
      result.sort!
      result.uniq!
      return result
    end

  end
end

def usage
  STDERR.print <<'End'
usage: cvssuck [options] cvsroot module
option: -h : print help message
        -s : grab only root, branchpoint, tagged revision and heads of branches.
	-o output-directory : specify output directory. (default: module)
End
  exit 1
end

def main
  $USAGE='usage'

  $debug = []
  $debug = [:command, :attic]

  parseArgs(2, nil, 'hs', 'o:')
  usage if 2 < ARGV.length

  usage if $OPT_h

  cvsroot = ARGV[0]
  mod = ARGV[1]
  mirrordir = $OPT_o || mod

  filter = $OPT_s ? Filter::Skeleton.new : Filter::All.new

  c = CVSMirror.new(mirrordir, cvsroot, mod)
  c.update(filter)
  c.cleanup
end

main
